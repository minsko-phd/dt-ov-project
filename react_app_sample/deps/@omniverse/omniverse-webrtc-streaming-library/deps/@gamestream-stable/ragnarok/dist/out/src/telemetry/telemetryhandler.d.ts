import { IEventEmitter, TelemetryEventPayload, TelemetryImpl, TelemetryEventBase } from "../dependencies";
import { clientShutDownCallbackType } from "../interfaces";
import { TelemetryEventProcessor } from "./telemetryeventprocessor";
import { StreamExitEventData } from "../rinterfaces";
import { VideoCodecType } from "../nskinterfaces";
/**
 * Interface passed to all the Ragnarok classes for handling telemetry generated by the internal objects.
 */
export interface TelemetryHandler {
    emitExceptionEvent(error: Error | DOMException | undefined, msg: string, file: string, lineno: number, colno: number, handled: boolean, category?: string): void;
    /**
     * Sends a WsCallResult telemetry event.
     * @param url - websocket connection url.
     * @param statusCode - code received from server when connection was closed.
     * @param serverId - server/haproxy instance in GFN where web socket connection was established.
     * @param disconnectionReason - server provided disconnection reason.
     * @param retryCount - retry number of the current websocket connection.
     * @param cleanDisconnection - optional, indicates if disconnection from server was clean or errored out.
     */
    emitGsWebSocketEvent(url: string, statusCode: number, serverId: string, disconnectionReason: string, retryCount: number, cleanDisconnection: boolean | undefined): void;
    emitGsFeatureEvent(featureName: string, supported: boolean, defaultEnabled: boolean, enabled: boolean, reason: string): void;
    emitDebugEvent(key1?: string, key2?: string, key3?: string, key4?: string, key5?: string): void;
    emitMetricEvent(metricName: string, valueString: string, valueDouble: number, valueInt1: number, valueInt2: number, valueInt3: number): void;
    emitGamepadEvent(gamepadName: string, vid: string, pid: string, index: number, hapticsSupported: boolean, hapticsFeedbackCount: number, primary: boolean, state: number, eventMap: string): void;
    emitSleepEvent(sleepTime: number, timeToSleep: number, sleepSequence: string, error: string, sessionId: string, subSessionId: string): void;
}
/**
 * Implements the telemetry support for Ragnarok2.0.
 * This class just caches the session specific data, constructs the individual telemetry events based on the parameters + telemetryEventIds + cached session data
 * and lets the TelemetryImpl base class process the events.
 */
declare class RagnarokTelemetryHandler extends TelemetryImpl implements TelemetryHandler {
    protected sessionId: string;
    protected subSessionId: string;
    protected cmsId: string;
    private isResume;
    private zoneAddress;
    protected totalGamepadEventsCount: number;
    protected exceptionCounts: Map<string, number>;
    protected totalExceptionCount: number;
    constructor();
    /**
     * This should be invoked when clients have requested for new session.
     * The values passed here will be added to the appropriate events (Stream_Start/Stream_Exit/DebugEvent etc)
     * @param subSessionId
     * @param sessionId
     * @param cmsId
     * @param isResume
     * @param zoneAddress
     */
    setSessionData(subSessionId: string, sessionId: string, cmsId: string, isResume: boolean, zoneAddress: string): void;
    /**
     * Clears the session properties provided in setSessionData API.
     * Should be invoked after sendStreamStartEvent and sendStreamExitEvent as they use cached session properties in event generation.
     */
    resetSessionData(): void;
    /**
     * Generates Streamer_Start event data and processes it.
     * Callers must invoke this after setSessionData API.
     * @param launchDuration - streaming start duration.
     * @param result
     * @param codec
     */
    sendStreamStartEvent(launchDuration: number, result: string, codec: VideoCodecType): void;
    /**
     * Sends Streamer_Exit exit.
     * Callers must invoked this after setSessionData API, before resetSessionData API.
     * @param result
     * @param exitReason
     * @param duration
     * @param codec
     * @param frameCount
     */
    sendStreamExitEvent(result: string, exitReason: string, duration: number, codec: VideoCodecType, frameCount: number): void;
    emitExceptionEvent(error: Error | DOMException | undefined, msg: string, file: string, lineno: number, colno: number, handled: boolean, category?: string): void;
    emitGsWebSocketEvent(url: string, statusCode: number, serverId: string, disconnectionReason: string, retryCount: number, cleanDisconnection: boolean | undefined): void;
    emitGsFeatureEvent(featureName: string, supported: boolean, defaultEnabled: boolean, enabled: boolean, reason: string): void;
    emitDebugEvent(key1?: string, key2?: string, key3?: string, key4?: string, key5?: string): void;
    emitMetricEvent(metricName: string, valueString: string, valueDouble: number, valueInt1: number, valueInt2: number, valueInt3: number): void;
    emitGamepadEvent(gamepadName: string, vid: string, pid: string, index: number, hapticsSupported: boolean, hapticsFeedbackCount: number, primary: boolean, state: number, eventMap: string): void;
    emitSleepEvent(sleepTime: number, timeToSleep: number, sleepSequence: string, error: string, sessionId: string, subSessionId: string): void;
    /**
     * todo: move this to base class.
     * @param message
     * @returns
     */
    private canSendExceptionEvent;
}
export declare const StreamKitTelemetryHandler: RagnarokTelemetryHandler;
/**
 * Provides telemetry handling for Ragnarok1.0.
 * The functionality of telemetry caching and uploading is implemented in TelemetryProcessor.
 * Delete this during cleanup of Ragnarok1.0 code.
 * This class overrides the processEvent of base class to support emitting telemetry event.
 */
export declare class LegacyTelemetryHandler extends RagnarokTelemetryHandler {
    private eventEmitter;
    private telemetryEventProcessor;
    private clientShutDownCallback?;
    constructor(_eventEmitter: IEventEmitter, telemetryEventProcessor: TelemetryEventProcessor);
    setClientShutDownCallback(clientShutDownCallback?: clientShutDownCallbackType): void;
    dispatchEvent(event: TelemetryEventPayload): void;
    setSessionId(sessionId: string): void;
    setSubSessionId(subSessionId: string): void;
    setGameDetails(cmsId: string, name: string): void;
    emitLaunchEvent(sessionId: string, subSessionId: string, isResume: boolean, zoneAddress: string, launchDuration: number, result: string, codec: VideoCodecType, cmsId: string, networkSessionId: string): void;
    processEvent(event: TelemetryEventBase<any>, priority?: boolean | undefined): void;
    /**
     * Exit event handling follows the below precedence:
     * 1. If the client has registered for ShutDownCallback, we call it with the eventPayload
     * 2. If ShutDownCallback not available or fails to send the event, send the Exit event using beacon API
     */
    private processExitEvent;
    sendExitAnalyticsEvent(exitEventData: StreamExitEventData, pollingDone: boolean): void;
    sendCachedExitEvent(pollingDone: boolean): Promise<void>;
}
export {};
