import { AuthInfo, DeviceOS, DeviceType, NetworkType } from "./dependencies";
import { ScErrorCode } from "./gserrorcode";
import { AdUpdate, AppLaunchMode, AudioFormat, ClientType, ConnectionInfo, MetaData, MonitorSettings, SessionState, SessionUpdate, StreamingFeatures } from "./interfaces";
/**
 * Callback to provide the session details, progress state, queue position and ad details to client during start/resume session.
 * @see SessionControl.startSession and @see SessionControl.resumeSession
 */
export declare type SessionUpdateCallback = (sessionUpdate: SessionUpdate) => void;
/**
 * Details of the session established in GeForce NOW server.
 * This object should be serialized and passed to NvidiaStreamKit.getStreamStartParameters to obtain the streaming parameters.
 */
export declare interface Session {
    /** Unique Id to identify current session. */
    sessionId: string;
    /** Unique Id generated by SessionControl library for identifying each start/resume requests to the server. */
    subSessionId: string;
    /** Current state of the session on server. */
    state: SessionState;
    /** Id of the application launched on server, this application content will be streamed. */
    appId: number;
    /** GPU resource provided for this session. */
    gpuType: string;
    /** Id of the device which requested the session or the device which is currently streaming. */
    deviceId: string;
    /** FQDN of zone where the resources are allocated for this session. */
    zoneAddress: string;
    /** Name/Id of the zone. This is extracted from the zoneAddress, can be used for telemetry purpose if required. */
    zoneName: string;
    /**
     * Launch mode of the remote application. When resuming an existing session, clients can use this field to determine if raw touch inputs should be sent to server.
     * see NvidiaStreamKit.StreamStartParameters.enableTouchInput
     */
    appLaunchMode: AppLaunchMode;
    /**
     * Properties of virtual monitors attached for the session.
     * Streaming resolutions and frame rate should be decided based on this property.
     */
    monitorSettings: MonitorSettings[];
    /** Signaling and media connection information. */
    connectionInfo: ConnectionInfo[];
    /** Finalized streaming features negotiated by the server */
    finalizedStreamingFeatures?: StreamingFeatures;
}
/**
 * Initialize parameters for SessionControl object passed in @see createSessionControl API.
 * Consider all fields mandatory for production. Majority of the fields are sent as NV-* header in http request and should adhere to
 * https://docs.google.com/document/d/1MGe199idCH1jbFns0NrIBVayJTqE2QxOS69uFBVQKyI/edit#bookmark=id.4oj2lbotllf7
 */
export declare interface InitializeParameters {
    /**
     * Server Address to perform getActiveSessions request.
     * New session request uses serverAddress from SessionParameters.
     * Resume/AdUpdate/Delete APIs sends to server where session resource was allocated.
     * Library caches the above info during startSession and getActiveSessions API execution.
     */
    serverAddress: string;
    /**
     * Version of the client application, this data can be differ between platforms.
     * Android client uses x.y format, web and other native clients use a.b.c.d format.
     * In future GeForce NOW server will use this data to reject session requests from older client versions.
     */
    clientAppVersion?: string;
    /** GUID associated with the device. */
    deviceId: string;
    /**
     * Unique ID for the client application registered in LCARS/Chroma.
     * Data sent to server in NV-Client-ID http header.
     */
    clientId?: string;
    /** Indicates client platform name, every platform should have separate string. */
    clientPlatformName: string;
    /** Data sent to server in NV-Client-Type http header. */
    clientType: ClientType;
    /** Data sent to server in NV-Device-Type http header. */
    deviceOs?: DeviceOS;
    /**
     * Data collected in open telemetry tracing of APIs and http requests.
     * Refer Tracing section in README for more details on traces collected by this library.
     */
    deviceOsVer?: string;
    /** Data sent to server in NV-Device-Type http header. */
    deviceType?: DeviceType;
    /** Data sent to server in NV-Device-Make http header. */
    deviceMake?: string;
    /** Data sent to server in NV-Device-Model http header. */
    deviceModel?: string;
    /** Should be set only from browser clients. Data sent to server in NV-Browser-Type http header. */
    browserType?: string;
    /**
     * Data sent to server in NV-Client-Streamer http header.
     * This data should be obtained from getStreamerType API of NvidiaStreamKit.
     */
    clientStreamer: string;
    /**
     * Map of application specific http headers (key-value) to be sent to server.
     * All the headers in this field are passed to server. If there are any NV-* headers mentioned above, it will override the above provided values.
     */
    clientHeaders?: Map<string, string>;
}
/**
 * Session properties to be sent to GeForce Now server.
 * GeForce Now server might not be able to honor all the properties, clients must check the Session object for the properties applied to the session.
 * Many streaming related properties of this API can be set by @see updateSessionParameters API with the response received from the ClientModeSelection library.
 * Refer to the documentation of updateSessionParameters API to identify which properties will be set/updated by the API.
 */
export declare interface SessionParameters {
    /** Optional FQDN address of the server where a new session needs to be requested.
     * If not set, the request will be sent to Zone provided in InitializeParameters.serverAddress
     * For resume cases, this parameter is no-op, resume request will be sent to zone where session has been established.
     */
    serverAddress?: string;
    /**
     * Unique identifier for the application that needs to be streamed from server.
     * This parameter is also known as CMSID in GeForce NOW.
     */
    appId: string;
    /** Device language in RFC 3066 code, but with '_' like en_US. http://www.i18nguy.com/unicode/language-identifiers.html */
    clientLocale?: string;
    /** Client systems TimeZone Offset in milliseconds, if this value is not set, it is calculated from JS API which might be wrong on some platform like Android. */
    clientTimeZoneOffset?: number;
    /** Indicates if the user has linked the platform account with GeForce NOW service. */
    accountLinked?: boolean;
    /** Custom data sent from GFN partner applications, this data will be plumbed all the way to VMs running the remote application. */
    partnerCustomData?: string;
    /** Informs the server to save the remote applications graphics settings changes by users to be used in next session. */
    enablePersistingInGameSettings?: boolean;
    /** Users age in years required for Ads category selection. */
    userAge?: number;
    /** Client specific Key-value pairs to be sent to server */
    metaData?: MetaData;
    /**
     * Number of virtual monitors and its properties to be set up for the session.
     * The resolution of the monitors determines the final selected resolution.
     */
    monitorSettings: MonitorSettings[];
    /** Stereo/surround audio format to be requested. */
    requestedAudioFormat?: AudioFormat;
    /**
     * Remote applications launch mode on the server.
     * If the remote application supports raw touch inputs (provided in AppInfo response from GeForce NOW server), then clients can set TouchFriendly mode on
     * client platforms that support raw touch inputs.
     * Note: Many client platforms support raw touch inputs, enabling touch on specific platforms is determined by business logic.
     * True touch inputs are enabled only on Mobile and Shield devices.
     * For remote applications which doesn't support raw touch inputs, clients can set GamepadFriendly mode for platforms where gamepad would be preferred input mode.
     * Ex: Console, Mobile devices.
     * Note: In GeForce NOW service steam application will be launched in Big Picture mode when appLaunchMode is GamepadFriendly, its no-op on other gaming platforms.
     */
    appLaunchMode?: AppLaunchMode;
    /** Server VMs system keyboard layout. */
    keyboardLayout?: string;
    /**
     * Bitmap value representing the controllers connected in client.
     * This value should be obtained from getGamepadBitmap API of NvidiaStreamKit.
     */
    remoteControllersBitmap?: number;
    /**
     * Requested features to enable on the server. The server may choose to disable features that aren't supported or
     * allowed. The finalized negotiated features can be found in @see Session.finalizedStreamingFeatures
     */
    streamingFeatures?: StreamingFeatures;
}
/**
 * Returned asynchronously from @see SessionControl.startSession and @see SessionControl.resumeSession API.
 * If SessionStartResumeResult.code == ScErrorCode.Success then session start/resume is success and is ready for streaming connection, else failure.
 * The SessionStartResumeResult.session will contain the details of the session established on server. This parameter can be passed to
 * NvidiaStreamKit to generate the parameters for streaming connection.
 * If there are active sessions for the user and GeForce NOW server is unable to create a new session then start/resume API will return
 * code = ScErrorCode.SessionLimitExceeded and list of active sessions will be provided in activeSessions parameter.
 * Clients must use active sessions appId and state fields to determine if there is any resumable active session for the requested app.
 * If there is a resumable session, then attempt to resume using @see SessionControl.resumeSession, else delete an existing session using @see SessionControl.deleteSession
 * and then attempt to start a new session.
 * @note resume requests are only accepted by GeForce NOW server in few states, @see isResumableSessionState or @see getResumableSession
 */
export declare interface SessionStartResumeResult {
    /** Unified error code, ScErrorCode.Success indicates session was successfully started/resumed on server, else failure. */
    code: ScErrorCode;
    /** A unique GUID created for identifying every start/resume session request. This value should be passed to NvidiaStreamKit and collected in telemetry.*/
    subSessionId: string;
    /** Session object which contains details of the session established on server.
     * This will be populated if we receive a session response from the server. Refer 'code' field to verify if session setup was success or not.
     * This object should be used to configure the streaming connection parameters of NvidiaStreamKit. Refer NvidiaStreamKit.getStreamStartParameters
     */
    session?: Session;
    /** If populated, will contain the active sessions in the GeForce NOW service for the user.
     *  @see getResumableSession to find an active session which can be resumed.
     */
    activeSessions?: Session[];
    /** Zone which provided the response to client. Will not be set if request never reached server. */
    zoneName?: string;
}
/**
 * Returned by @see SessionControl.getActiveSessions, contains details of users active sessions in GeForce NOW service.
 */
export declare interface ActiveSessionsResult {
    /** If value is ScErrorCode.Success then successfully fetched the session information from server. */
    code: ScErrorCode;
    /** List of active sessions, will be empty if there are no active sessions for the user.
     *  @see getResumableSession to find an active session which can be resumed.
     */
    activeSessions?: Session[];
    /** Zone which provided the response to client. Will not be set if request never reached server. */
    zoneName?: string;
}
/**
 * Returned by @see SessionControl.getSessionInfo, contains details of the requested session.
 */
export declare interface SessionInfoResult {
    /** If value is ScErrorCode.Success then successfully fetched the session information from server. */
    code: ScErrorCode;
    /** Details of the requested session. */
    session?: Session;
    /** Zone which provided the response to client. Will not be set if request never reached server. */
    zoneName?: string;
}
/**
 * Wrapper for all the session related requests (start/resume/get/ad update/delete) to GeForce NOW servers.
 * Clients must use this class for creation and management of a GeForce NOW sessions.
 * The Session object returned by this class can be passed to NvidiaStreamKit to extract the streaming related parameters.
 */
export declare interface SessionControl {
    /**
     * Sets the authorization information which will be used in authenticated HTTP requests to the server.
     * This API must be called before startSession, deleteSession and getActiveSessions, else those APIs will return error.
     * If any of the APIs return ScErrorCode.InvalidAuthenticationExpired then clients must refresh the tokens and invoke this API.
     * @param authInfo - authentication type and token.
     **/
    setAuthInfo(authInfo: AuthInfo): void;
    /**
     * Clients must call this function whenever clients network type changes.
     * The networkType value will be collected in telemetry events. By default the clients NetworkType will be treated as UNKNOWN.
     * NetworkType information might not be available in all platforms, where not available this API can be skipped. Ex: Browser platforms (non ChromeOS)
     * @param networkType - current NetworkType
     */
    setNetworkType(networkType: NetworkType): void;
    /**
     * This is a cancellable asynchronous API which starts a new session on the server.
     * This API requires authentication info, clients must call @see SessionControl.setAuthInfo before executing this API.
     * Multiple updates might be provided to client in SessionUpdateCallback which informs the progress of the session setup process or ad to be displayed to the user.
     * If any ad information is provided in the SessionUpdateCallback, clients are expected to play ad and inform the status of ad play through @see SessionControl.updateAdState.
     * Every startSession API will generate a unique GUID known as subSessionId and is returned in the result and SessionUpdateCallback.
     * @note In some cases clients might need to resume or delete an existing session, @see SessionStartResumeResult for more details.
     * @param startParameters - session properties to be requested from server.
     * @param cancelController - executing abort on this controller will result in canceling the session setup process.
     *                           Promise will resolve with SessionStartResumeResult.code = ScErrorCode.SessionSetupCancelled or ScErrorCode.SessionSetupCancelledDuringQueuing
     *                           Note: Session will not be deleted on server and if needed clients must explicity call @see SessionControl.deleteSession
     * @param updateCallback -  callback to provide the updates of the session setup process.
     * @return a promise which resolves with @see SessionStartResumeResult.
     *         SessionStartResumeResult.code will be set to ScErrorCode.InvalidOperation if a startSession or resumeSession API execution is already in progress. No use case supports having more than one session in parallel in clients.
     *         Or if no authentication info was provided. @see SessionControl.setAuthInfo
     */
    startSession(startParameters: SessionParameters, cancelController: AbortController, updateCallback: SessionUpdateCallback): Promise<SessionStartResumeResult>;
    /**
     * This is a cancellable asynchronous API which requests server to prepare an existing sessions server components to be ready for new connection.
     * This API requires authentication info, clients must call @see SessionControl.setAuthInfo before executing this API.
     * Upon resume request server will disconnect any existing streaming connection.
     * The returned promise will resolve once session is ready for reconnection or in error case.
     * @note resume requests are only accepted by GeForce NOW server in few session states, @see ResumableSessionState.
     * @param sessionId - Id of the existing session to be resumed.
     * @param resumeParameters - session properties to be modified for an existing session.
     * @param cancelController - executing abort on this controller will result in canceling the session setup process.
     *                           Promise will resolve with SessionStartResumeResult.code = ScErrorCode.RequestCancelled
     *                           Note: Session will not be deleted on server and if needed clients must explicity call @see SessionControl.deleteSession.
     *                           SessionStartResumeResult.code will be ScErrorCode.RequestCancelled
     * @param callback - callback to provide the updates of the session resume process.
     * @return a promise which resolves with @see SessionStartResumeResult.
     *         SessionStartResumeResult.code will be set to ScErrorCode.InvalidOperation if a startSession or resumeSession API execution is already in progress. No use case supports having more than one session in parallel in clients.
     *         Or if no authentication info was provided. @see SessionControl.setAuthInfo
     */
    resumeSession(sessionId: string, resumeParameters: SessionParameters, cancelController: AbortController, callback: SessionUpdateCallback): Promise<SessionStartResumeResult>;
    /**
     * This is an asynchronous API which terminates(deletes) a session on the server.
     * This causes disconnection of existing streaming connection and freeing the server resources associated with the session.
     * This API requires authentication info. Clients must call @see SessionControl.setAuthInfo before executing this API.
     * @param sessionId - Id of the session to be deleted.
     * @param cancelController - executing abort on this controller will result in aborting the HTTP request to server.
     *        Promise will resolve with ScErrorCode.RequestCancelled.
     * @return a promise which resolves with ScErrorCode.
     *  1. ScErrorCode.Success - session was successfully deleted on the server.
     *  2. ScErrorCode.InvalidSessionIdNotFound - session doesn't exists on server, session could have already been deleted on server.
     *  3. Other - Failed to delete the sessions.
     */
    deleteSession(sessionId: string, cancelController?: AbortController): Promise<ScErrorCode>;
    /**
     * This is a cancellable asynchronous API which provides the list of active sessions for the user in GeForce NOW server.
     * Clients can use this request to determine if there is any active session for the user which can be resumed.
     * This API requires authentication info. Clients must call @see SessionControl.setAuthInfo before executing this API.
     * @param cancelController - executing abort on this controller will result in aborting the HTTP request to server.
     *        ActiveSessionsResult.code will be ScErrorCode.RequestCancelled.
     * @return a promise which resolves with ActiveSessionsResult.
     *         ActiveSessionsResult.code will be set to ScErrorCode.InvalidOperation if no authentication info was provided. @see SessionControl.setAuthInfo
     */
    getActiveSessions(cancelController: AbortController | undefined): Promise<ActiveSessionsResult>;
    /**
     * This is cancellable asynchronous API which gets the details of a session from server.
     * @param sessionId - Id of the session to be fetched.
     * @param cancelController - executing abort on this controller will result in aborting the HTTP request to server.
     *        SessionInfoResult.code will be ScErrorCode.RequestCancelled.
     */
    getSessionInfo(sessionId: string, cancelController: AbortController | undefined): Promise<SessionInfoResult>;
    /**
     *  In few use cases GeForce Now service requires clients to display Ads to users while creating a session for the user.
     *  The Ads information are provided in the SessionUpdate callback. @see SessionControl.startSession
     *  Clients are expected to display Ads and inform the status of Ads display to the SessionControl library through this API.
     *  AdUpdate.adAction values to be set:
     *     START  - When client started displaying the ad.
     *     PAUSE  - When ad play is paused because of user navigating away from client application.
     *     RESUME - When ad play resumes after being paused.
     *     FINISH - When ad play completes.
     *     CANCEL - When User stopped ad play or client failed to play the Ad.
     *  Note: AdActions should flow in specific order
     *  1. START -> PAUSE|FINISH|CANCEL
     *  2. PAUSE -> RESUME|CANCEL
     *  3. RESUME -> PAUSE|FINISH|CANCEL
     *  4. No updates are accepted after FINISH or CANCEL update.
     *  Incorrect order of adAction will cause this API to return ScErrorCode.InvalidAdStateTransition.
     *  This API can throttle the ads update request to server if there are too many pause/resume updates for an Ad.
     *  Returns ScErrorCode.Success if the AdUpdate is successfully accepted. AdUpdate is sent to server asynchronously.
     *  The next SessionUpdate callback will provide the latest status of the ad on the server.
     *  @param  adUpdate: AdUpdate to be sent to the server. @see AdUpdate documentation for all the details to be populated by client.
     *  @return ScErrorCode.Success if the request was successfully accepted.
     *          ScErrorCode.InvalidOperation - if startSession is not in progress.
     *          ScErrorCode.InvalidAdStateTransition - wrong sequence of ad update.
     *  @note 1. Ad play can be canceled on the client device for multiple reasons, based on the value of AdUpdate.cancelReason the
     *           the session might get terminated in few cases or session will transition to ready for streaming (startSession promise resolve)
     *           only after waiting for a minimum duration.
     *        2. Clients can keep invoking this API without needing to monitor the state of the ad received from server.
     *           AdUpdate request can be grouped and sent to server. Since requests are executed sequentially the AdState provided in SessionUpdate callback
     *           might not match the AdActions provided by the client to the SessionControl library.
     */
    updateAdState(adUpdate: AdUpdate): ScErrorCode;
}
/**
 * Creates a SessionControl interface which provides functionality to perform session related requests to GeForce NOW server.
 * @param initParams - parameters to initialize the SessionControl interface.
 * @returns an initialized SessionControl interface.
 * @throws {Error} - If unable to initialize the SessionControlImpl.
 */
export declare function createSessionControl(initParams: InitializeParameters): SessionControl;
